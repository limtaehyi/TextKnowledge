1. 멀티스레딩
 - 윈도우 작업관리자 창에서 볼 수 있듯이 기기 안에서 실행중인 프로세스가 여러개 인것을 멀티프로세싱이라고 한다.
 - 각 프로세스에서는 독립된 메모리 공간이 있다. 기본적으로 서로 다른 프로세스는 상대의 메모리 공간을 읽고 쓸 수 없다.(독립성)
 - 프로세스 안에는 여러개의 스레드와 각각의 호출 스택이 있고 하나의 힙을 공유한다.
 - 스레드의 라이프 사이클은 생성되어 시작된후 실행중인 상태가 된다. 여기에서 기다리면 대기상태가 되며 호출 될시 깨어나서 다시 실행중인 상태가 된다. 그후 종료시 소멸된다.
 - 멀티스레딩 프로그램을 해야할 경우는 크게 3가지로 오래걸리는일 하나와 빨리 끝나는 일 여럿이 있을 때, 어떤 긴 처리를 진행하는 동안 다른 짧은일을 할때, 기기에 있는 CPU를 모두 활용 해야 할때가 있다.

 컨텍스트 스위치
 - 물리적으로 떨어져 있는 두가지 일을 시키면 보통 사람은 한가지 일을 끝낸후 다른 장소로 이동하여 일을 한다. 하지만 cpu는 그렇지 않고 두 장소를 이동하며 일을 하다 말고 하다말고 한다. 이때 각 스레드를 실행하다 말고 다른 스레드를 실행하는 과정을 컨텍스트 스위치라고 한다.
 - 두가지 일을 동시에 하는건 생각보다 일이 많은데 한가지 일을 하다만후 다른 일을 실행하려면 기존에 있던 일을 스택에 저장(호출 스택, 상태 등)한후 다른 일의 기존 상태를 복원 한다음에 다시 강제 이동하여 일을 처리해야 한다.
 - 컨텍스트 스위치를 하다보면 연산량이 많아져 배보다 배꼽이 커지는 일이 발생한다.
 - 만약 2개 이상의 스레드가 한가지 값에 동시에 접근하는 경우가 있는데 이때 아무도 모르는 이상한 결과 값을 낳는 경우가 있는데 이것을 데이터 레이스라고 한다.
 - '스레드에서 어떤정보인 x를 사용하는 동안 다른 스레드가 접근하지 못하게 한다.' 즉 데이터 레이스를 피하기 위해 값을 보호해야 하는데 이때 사용하는 것이 임계영역, 뮤텍스, 락기법이다.

2. 임계영역, 뮤텍스, 세마포어
 임계영역, 뮤텍스
 - x, y를 보호하는 뮤텍스 mx를 만들고 x, y에 접근하기 전에 mx에 사용권을 얻어 사용한 후 사용권을 해제하는 코드이다.
 - ex
 std::mutex mx;
 mx.lock();
 read(x);
 write(y);
 sum(x);
 mx.unlock();
 - 만약 read(x)를 하다가 예외가 발생하면 mx.unlock() 이 실행이 안될수도 있다. 이럴 때 try, catch로 일일이 다 감싸기에는 코드가 비효율 적이 되는데 이럴 때 자동으로 잠금해제가 되는 클래스가 있는데 이것이 lock_guard 이다.
 - ex
 std::recursive_mutex mx;
 lock_guard<recursive_mutex> lock(mx);
 read(x);
 write(y);
 sum(x);
 - 뮤텍스는 큼직하게 범위를 잡아야 한다. 만약 잘게 나누어 잡으면 문제가 발생하는데 첫번째로 뮤텍스를 엑세스 하는 과정자체가 무겁기 때문에 오히려 프로그램 성능이 떨어진다. 두번째로는 프로그램이 복잡해질 뿐더러 교착 상태 문제가 쉽게 발생한다.
 - 만약 두개의 스레드 a와 b가 있고 실행한다고 가정해보자. a에서는 x라는 변수를 lock하고 y를 사용하려고 하고 b에서는 y라는 변수를 lock하고 x를 사용하려고 하면 프로그램은 돌아가지 않는다.
 
 잠금 규칙
 - 교착상태를 예방하기 위해서는 뮤텍스의 잠금 순서를 먼저 그래프로 그려낸후 거꾸로 잠근것이 없는지 체크하는 것이 좋다.
 - 만약 a->b->c로 잠근다면 아래와 같은 코드로 표현된다.
 - ex
 lock(a)
 lock(b)
 lock(c)
 unlock(c)
 unlock(b)
 unlock(a)
 - a->b로 잠그는 것도 좋고 a를 건너 뛰고 b->c로 잠그는 것도 가능하다. 순서를 어기지는 않아서 가능한 것이다. 또한 a->c도 가능하다. 하지만 b->a는 교착 상태가 발생한다. 또한 c->a도 데드락이 발생한다.  
 - 재귀 뮤텍스도 가능한데 한 값을 두번 잠그는 것이나 a->b->c->b->a도 가능하다. 하지만 a->c->b->c->a는 데드락이 발생한다.

 스레드 풀링
 - 보통 멀티스레딩 프로그래밍을 한다면 공통된 데이터나 그룹 목록리스트 보다는 그룹단위로 잠금 범위를 설정하는 것이 적절하다.
 - 처음 프로그램 개발할 때 스레드의 개수와 스레드의 일을 정의하는 것은 어려운 일이다. 만약 클라이언트 마다의 스레드를 배정한다면 클라이언트의 수가 많아 질수록 그에 따른 스레드 개수와 호출스택 또한 비정상적으로 커지고 그 개수에 따른 스레드의 sleep, wake 처리로 인한 불필요한 cpu 연산, 컨텍스트 스위치 현상도 발생한다. 
 - 따라서 스레드 개수를 클라이언트 개수만큼 두지 않고 스레드 풀링을 사용하는데 특정 스레드 개수를 설정하고 이벤트를 순서대로 큐로 세워둔 후 한개씩 처리하는 방식이다. 투표소 같이 투표할 사람들은 줄을 서 있고 한사람식 투표공간에서 일을 끝낸후 나오는 방식, 화장실 줄서서 빈곳에 들어가 처리하는 방식을 생각하면 편하다.
 - 스레드의 개수를 정하는 기준이 있는데 어떤 서버의 주 역할이 cpu 연산만 하는 스레드라면 cpu의 개수와 동일하게 잡아도 충분하다. 하지만 데이터베이스나 파일등 다른 것에 엑세스하여 불러오는 시간이 발생(디바이스 타임) 한다면 스레드 개수는 cpu보다 많아야 한다.

 이벤트
 - 멀티스레드 프로그래밍의 도구는 임계 영역과 뮤텍스 뿐만 아니라 이벤트도 있다. 이벤트는 sleep 상태의 스레드를 깨우는 도구이다.
 - 이벤트는 스레드간 소통을 하며 일을 처리할 때 유용하며 만약 스레드 1에서 일을 끝마친 후 스레드 2에 알리는 일등을 할 수 있다.
 - 윈도우에서 이벤트는 자동과 수동이 있는데 자동에서는 이벤트 상태가 1(활성화)가 되었을때 이벤트를 기다리던 스레드가 있을 때 그 스레드를 깨우고 상태가 자동으로 0(비활성화)가 된다. 수동은 이벤트 상태가 1이 되었을때 이벤트를 기다리던 스레드가 깨워 지지만 이벤트 상태값은 1로 남는다.
 - 만약 스레드 둘 이상이 이벤트를 기다리는 경우 자동은 한개만 깨어나고 수동은 모두 깨어난다. 이런 경우를 대비해서 맥박(pulse)기능도 있다. 이벤트에 한번만 1로 바꾸고 다시 0으로 바꾸는 기능이다. 수동이벤트에 맥박을 1회만 주면 수동 이벤트라 하더라도 상태가 1이 되었다가 다시 0으로 바뀐다. 이때 둘이상 이벤트를 기다리고 있으면 모든 스레드가 깨어난다.

 세마포어
 - 뮤텍스나 임계영역은 스레드 1개만 자원을 엑세스 할수 있게 하는데 세마포어는 여러개의 스레드가 자원을 엑세스 할 수 있게 한다.
 - 세마포어도 상태값을 가지고 있으며 값은 0 이상이고 초기값은 최대 엑세스 가능한 스레드 개수이다. 스레드가 세마포어에 자원 엑세스를 요청하면 상태 값은 1 감소한다. 그리고 스레드는 자원 엑세스를 허가 받고 다른 스레드로 자원 엑세스를 요청하고 결국 상태값은 0이 된다.
 - 세마포어는 상태값이 0인 상황에서는 자원 엑세스를 허락하지 않기 때문에 스레드가 자원 엑세스를 요청하면 그 스레드는 sleep이 된다. 자원 엑세스를 마친 스레드는 세마포어에 통보하면 세마포어의 상태값을 1 증가시킨다. 
 - 세마포어는 이벤트와 비슷하지만 0,1만 사용되는 이벤트와 다르게 0 이상의 아무 값이나 가질수 있다는 차이가 있다.

 멀티스레드 프로그래밍 실수
 - 읽기, 쓰기 모두 잠금하지 않기 : 메모리에 값을 쓰고 있는데 다른 스레드가 접근해서 읽는 경우 버그 발생
 - 잠금 순서 꼬임 : 데드락 발생
 - 너무 좁은 잠금 범위 : 컨텍스트 스위치 발생시 운영체제에서 해아할 일이 많아짐, 멀티스레딩 프로그래밍의 이유가 퇴색됨
 - 디바이스 타임이 섞인 잠금
 - 잠금의 전염성으로 발생한 실수
 - 잠금된 뮤텍스나 임계 영역 삭제
 - 일관성 규칙 깨기


3. 소켓 프로그래밍

 블로킹 소켓
 - 소켓에는 각각 송신 버퍼, 수신 버퍼가 하나씩 존재한다. 먼저 송신 버퍼는 배열로 존재하며 송신 버퍼의 크기는 마음대로 조절 가능하고 FIFO 형식으로 작동한다. 만약 send(data)를 한다면 data는 일단 송신 버퍼에 채워지고 통신 선로를 통해 빠져나간다. 
 - 만약 송신 버퍼가 꽉차서 더이상 push가 불가능한 상태면 기존 송신 버퍼에 있는 내용이 빠져나가 공간이 생길때까지 기다리는 현상이 블로킹이다.
 - 반대로 수신 버퍼가 꽉 찼다고 가정했을때는 TCP 통신은 없고 TCP 연결만 살아 있는 상태가 된다. 즉 TCP 송신 함수로 송신 버퍼에 쌓는 속도보다 수신 함수로 수신 버퍼에서 데이터를 꺼내는 속도가 느리다고 해서 TCP 연결이 끊어지는 것이 아닌 송신 속도가 느린쪽에 맞춰 작동하는 것이다.
 - UDP 소켓은 당연하게도 수신 소캣의 버퍼가 부족하면 데이터그램은 그냥 버려지게 된다.

 논블록 소켓
 - 멀티스레딩 프로그래밍에서 여러개의 네트워크 대상과 통신을 한다면 그만큼 스레드를 만드는 것이 일반적이고 각 스레드는 통신을 하는데 네트워크 대상이 많으면 각 스레드는 빈번히 자다 깨다 할 것이다. 그러다 보면 스레드 간의 컨텍스트 스위치가 발생하고 자원 낭비가 발생할 것이다.
 - 소켓 송신 함수에서 계속 송신을 하는데 수신측이 따라가지 못한다면 언젠간 송신측의 송신소켓이 가득 찰것이고 블로킹이 발생할 것이다. 이럴 때 대부분 운영체제에서는 소켓 함수고 블로킹 안되게 API를 제공하는데 이걸 논블록 소캣이라고 한다.
 - 논블록 소켓의 사용 방법은 소켓을 논블록 소켓으로 전환한다 -> 평소처럼 송수신, 연결 함수를 호출한다 -> 논블록 소켓은 무조건 이 함수호출에 바로 리턴한다. 리턴 값은 성공, 또는 would block(블로킹이 될뻔한 상황) 오류 둘중 하나이다.
 - 논블록 소캣의 장점은 블로킹이 없으므로 중도 취소가 가능하다, 스레드가 1개이거나 적어도 소켓을 여러개 다룰 수 있다, 스레드가 1개이거나 적음으로 연산량 낭비가 되지 않고 호출 스택 메모리도 낭비되지 않는다.
 - 단점으로는 소켓 Input/Output 함수가 리턴한 값이 would block일 경우 재시도 호출 낭비가 발생한다, 소켓 I/O 함수 호출할 때 입력한 데이터 블룩에 대한 복사 연산이 발생, connect 함수는 재시도 호출 하지 않지만 send, receive 함수는 재호출 해야 하지만 api가 일관되지 않는다는 문제가 발생함.
 - 단점중 재시도용 호출 낭비가 있는데 만약 TCP 소켓의 send를 봤을때 송신 버퍼에 1바이트라도 있으면 송신 가능 상태가 된다. 만약 보내려는 데이터가 5바이트이지만 송신 버퍼에 공간이 1바이트만 있으면 1바이트만 송신 버퍼에 채워져 성공적으로 리턴된다. TCP는 분할 송수신이 가능하니깐 하지만 UCP는 다르다.
 - UDP 소켓의 송신 버퍼에 1바이트라도 비어 있으면 I/O 가능하지만 5바이트를 보내려고 했더니 송신 소켓이 1바이트만 남아 있으면 would block이 발생하고 재시도를 하지만 여전히 would block 상태가 된다.
 - 소켓 송수신 함수에 들어가는 데이터 블록 인자를 성공적으로 실행하면 사용자 프로세스내 데이터 블록에서 운영체제 커널내 소켓 버퍼로 복사 연산이 발생하는데 이런 문제점들을 해결해 주는 기법이 Overlapped 또는 비동기 I/O기법이다.

 Overlapped, async I/O
 - 기존 논블록 소켓은 소켓이 I/O 가능한 것이 있을때 까지 기다린후 논블록 엑세스를 하고 would block이 발생하면 그대로 두고 그렇지 않으면 결과를 리턴하는데 Overlapped I/O는 소켓에 대해 Overlapped 엑세스를 걸고 엑세스가 성공을 확인후 결과값을 가져와 나머지를 처리함.
 - Overlapped I/O 함수는 바로 리턴이 되지만 운영체제로 해당 I/O 실행이 별도로 동시간대에 진행된 상태이다. 운영체제는 소켓 함수에 인자로 있던 데이터 블록을 백그라운드에서 엑세스를 한다.
 
 Overlapped 장단점
 - 소켓 I/O 함수 호출 후 would block 인 경우 재시도 호출 낭비가 없다. <-> 완료 되기 전까지 Overlapped status 객체가 데이터 블록을 중간에 훼손하지 말아야한다.
 - 소켓 I/O 함수를 호출 할때 데이터 블록에 대한 복사 연산을 없앨수 있다. <-> 윈도우에서만 제공하는 기능이다.
 - send, receive, connect, accept 함수를 한번 호출하면 완료 신호는 한번만 와서 결과물이 깔끔하다. <-> accept, connect 함수 계열의 초기화가 복잡함

 Overlapped, 논블록 차이
 - 논블록에서의 I/O 실행 상태에서 송신 버퍼에 1바이트라도 여유가 있으면 송신가능, 수신 버퍼에 1바이트라도 여유가 있으면 수신가능 상태를 I/O 가능 상태라고 부름
 - Overlapped I/O 실행 상태에서 송신이 진행중이고 완료가 아직 안됐으면 '송신이 아직 완료 대기중' 상태, 수신이 진행중이고 완료가 안됐으면 '수신이 아직 완료 대기중' 상태라고 부르고 통칭 I/O 완료 대기, I/O 실행중 이라고 부름
 - 논블록은 상태 확인 후에 뭔가 하고 Overlapped는 저지르고 결과를 확인하여 논블록을 리액터, Overlapped를 프리액터 패턴이라고 부름


 epoll
 - epoll은 소켓이 I/O 가능 상태가 되면 이를 감지해서 사용자에게 알려주는 역할을 한다.

 IOCP
 - epoll은 논블록 소켓을 대량으로 가지고 있을때 효율적으로 처리해주는 API인데 Overlapped I/O를 다루는 운영체제도 내놓은 것이 I/O Completion Port이다.

