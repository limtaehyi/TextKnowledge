1. UML
 - 럼바우 OMT, yacobson OOSE(use case), booch OOD
 - 가시화, 구현, 명세화, 문서화
 - 사물, 관계, 도해 == things, relationship, diagram
 - UML 모델링 세분류
  ㄴ 기능적(유즈케이스)
  ㄴ 정적(클래스, 패키지, 컴포넌트, 배치)
  ㄴ 동적(상호작용, 시퀀스, 협동, 액티비티, 상태)
2. 애자일
 - xp (용기, 단순화, 커뮤니케이션, 피드백, 존중)
 - scrum (매일 15분 회의, 30일 deadline, 반복과 업무추적 중점) 
 - up
 - crystal (tailoring)
 - FDD
3. 모델링
 - 기능적 (연결 =, 순차 +, 선택 [], 반복 {}n, 선택 ())
 - 자료적 (E-R)
 - 동적 (유즈케이스)
4. 분석자동화도구 
 - CASE
  ㄴ 시각적 자료 최대화
  ㄴ 코드 다 생성해줌
 - HIPO
  ㄴ 문서화도구 + 시각적 차트
5. UI 개발 도구 유형
 - 추상적에서 - wireframe - mockup(파워, 발사믹 목업) - prototype(카카오 oven) - storyboard(Axure) - use case(visio) - 명목적 순으로
6. Code & yourdon
 - E-R 다이어그램으로 객체 행위 모델링
7. UML 작성방법
 - <<길러멧>>
 - 반드시포함(include), 실행할수도 안할수도(extend), 전체 메소드가 추상이고 인스턴스 못만듬(interface), 오래 지속되는 행위나 정수(entity), 외내부 소통(boundary)
8. 아키텍쳐 프레임워크
 - perry and wolf (요소, 표현법, 근거)
 - shaw and garlan (컴포넌트, 커넥트, 패턴)
 - siemens four view (개념적 아키텍처, 모듈, 코드 아키텍처, 실행 뷰)
 - 4+1 (논리, 사용사례, 구현, 프로세스, 배치)
9. 모듈화 원리
 - 응집도 높아야 좋음
 - 결합도 낮아야 좋음
 - 응집도 수준
  ㄴ 높음 -> 내용, 공통, 외부, 제어, 스템프, 자료 -> 낮음
 - 결합도 수준
  ㄴ 낮음 -> 우연적, 논리적, 시간적, 절차적, 통신적, 순차적, 기능적 -> 높음
10. 객체지향 설계원칙
 - 단일 책임원칙 (SRP) -> 객체는 하나의 책임만 갖도록 설계
 - 개방 폐쇄의 원칙 (OCP) -> 변화가 필요한 부분은 확장이 가능하지만 변경을 불가능
 - 리스코프 치환 (LSP) -> 상속받은 자식 타입은 부모타입이 사용되는 곳에서 대체 가능
 - 인터페이스 분리 (ISP) -> 객체의 기능과 입출력 분리
 - 의존관계 역전 (DIP) -> 참조의 대상은 파생 클래스가 아닌 추상 클래스여야 함
11. 객체지향 설계 시 연관성 유형
 - 연관화 (association) -> is member of
 - 분류화 (classification) -> is instance of
 - 일반화 (generalization) -> is a
 - 특수화 (specialization) -> is a
 - 집단화 (aggregation) -> is part of
12. GOF
 - 생성
  ㄴ Factory Method, Abstract Factory, Builder, Prototype, Singleton
 - 구조
  ㄴ Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
 - 행위
  ㄴ Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor
13. 미들웨어
 - 사용자들과 서버 사이에서 중계 (중계성, 호환성, 편의성)
 - EAI (enterprise application integration) : 내외부에 있는 이기종 애플리케이션을 연동 및 통합
 - ESB (enterprise service bus) : 웹을 기반으로 다양한 시스템들을 결합, 비동기식 연결 지원 MOM
 - RPC (remote procedure call) : 원격 접속
 - TP모니터 : 모니터링
14. 단위모듈
 - macro, function, inline
15. DRM 구성 기능
 - 패키저, 보안 컨테이너, 클리어링하우스, 컨트롤러
16. ISO
 - 프로세스 : 122, 155(spice), cmmi
 - 제품 품질 : 9126, 14598, 12119, 25000
17. ISO 프로세스
 - 122는 소프트웨어의 획득부터 유지보수까지의 모든 주기를 체계적으로 관리학 위한 생명주기 표준
  ㄴ 23, 95, 224의 프로세스, 활동, 산출물로 정의되어있음
  ㄴ 크게 획득, 공급, 개발, 운영, 유지보수로 나뉨
 - 155는 프로세스의 개선과 능력측정 관련 기준
  ㄴ 5, 40의 프로세스와 세부 프로세스로 구성
  ㄴ 불안정, 수행, 관리, 확립, 예측, 최적화순
 - cmmi는 sw개발 관련 능력이랑 조직 성숙도 평가와 지속적 품질 개선
  ㄴ 단계적 표현, 연속적 표현으로 나뉨
18. ISO 제품 품질
 - 9126은 사용자 관점에서 품질특성과 품질평가 척도 정의
  ㄴ 4, 6, 21의 세부 표준, 품질특성, 부특성으로 구성
  ㄴ 표준 구성은 품질특성, 외내부 메트릭스, 사용 중 품질로 나뉨
  ㄴ 기능성 : 적합성, 정확성, 상호호환성, 유연성, 보안성
  ㄴ 신뢰성 : 성숙성, 오류허용성, 회복성
  ㄴ 사용성 : 이해성, 습득성, 회복성
  ㄴ 효율성 : 실행효율성, 자원효율성
  ㄴ 유지보수성 : 해석성, 변경성, 안정성, 시험성
  ㄴ 이식성 : 환경적용성, 이식작업성, 일치성, 치환성
 - 14598은 제품 품질을 평가하는데 필요한 방법과 절차를 6개로 나눠놓은 표준
  ㄴ 반복성, 재현성, 공정성, 객관성
 - 25000 (square)는 sw 개발 프로세스에서 각 단계의 산출물이 사용자의 요구에 만족하는지 검증하기위한 평가모델, 측정기법, 평가 방안을 정의
  ㄴ 품질 모형, 관리, 측정
19. V&V; 검증, 확인
 - 검증 (Verification)은 sw 개발 단계별 산출물이 전단계의 요구사항과 조건에 부합하는지 확인
  ㄴ 점검 (Inspection)은 중재자와 회의를 주관하여 문제점을 발견하여 초기에 잡을수있음, 정형기술
  ㄴ Walkthrough는 설계서나 프로그램의 오류 검토회의, 코드를 대상으로 오류, 모순, 탈락등 여부 심의
  ㄴ 동료검토는 소규모 회의로 개발자 동료와 기술 리더등이 코드나 디자인 검토
 - 확인 (Validation)은 sw 제품이 고객의 요구사항을 충족하고 올바른 제품이 만들어 졌는지 테스트를 수행하여 확인
  ㄴ 단위(unit) 테스트는 모듈 단위 소프트웨어 기능만 분리하여 테스트
  ㄴ 하향식이면 스텁, 상향식이면 테스트 드라이버
  ㄴ 통합테스트(big-bang : 한꺼번에, top-down : 상위부터 하위방향, bottom-up : 하위부터 상위방향, sandwich : 양쪽에서) 
  ㄴ 시스템 테스트는 신뢰성, 견고성, 성능, 안정성등 비기능적 요구사항에 대한 오류 검증
  ㄴ 인수 테스트에서 알파는 테스터는 개발환경에 초대, 베타는 제한된 테스터수로 공개 테스트, 감마는 다수 이용자에게 배포 테스트 
  ㄴ 설치 테스트는 설치시 하드웨어나 인터페이스등을 포함하여 테스트
20. 테스트 원리
 - 결함 존재 밝힘의 원리(결함이 없다고 무결하지는 않음), 완벽한 테스팅 불가능(입력 경로, 조합이 무한대에 가까움), 초기 테스팅 시작의 원리(나비효과 조심), 결함 집중의 원리(팔레토의 20퍼에 80의 결함이 있다고 주장), 살충제 패러독스(창의성 떨어짐의 원리), 정황 의존성의 원리(적용하는 곳에 따라 테스트 수행방법이나 절차가 다양하다 못해 넘쳐남), 오류 부재의 원리(사용자의 요구사항에 충족 못한 경우에는 모든 결함을 찾아서 해결했다 해도 품질이 높다고 말 못함)
21. 블박, 화박
 - 블박
  ㄴ 동등분할기법 (equivalence partitioning) : 시스템이 요구하는 수치, 그 이상, 그 이하로 3개로 나눠서 테스팅
  ㄴ 경계값 분석 (boundary value analysis) : 시스템이 요구하는 수치의 최대치나 최소치 혹은 그 약간의 이상,이하값으로 테스팅(시스템이 요구하는 최대치 정수에 0.01정도 더 추가한다거나 최소치에 0.0000001정도 뺀값)
  ㄴ 오류 예측 : 오류 야기하는 입력값 입력
  ㄴ 원인-결과 : 입력값과 출력값을 분석하고 그래프로 표현하여 정상적인 그래프를 벗어나는 부분 확인 및 오류 발견
  ㄴ 제어흐름 : 동적인 제어흐름 모델을 도출 후 테스트
  ㄴ crud : crud
  ㄴ 결정 테이블 : 사용자의 결정이나 조건등 모든 동작을 정의하고 표로 표현후 테스팅
  ㄴ 예외 : 예외 메세지나 상황을 물고 늘어지기
  ㄴ 상태 전이 : 시스템 상태나 모드가 변경되는 조건이나 행위를 정의 후 테스트 진행
  ㄴ 긍정과 부정 : sw가 잘못되었다고 가정하거나 올바르다고 가정해서 입력값을 넣어 비교하는 테스트
  ㄴ 랜덤 : 랜덤
  ㄴ 회귀 : sw를 수정하고 나서 요구사항을 계속 만족하는지 또는 새로 생겼는지 검증
  ㄴ 쓰레드 : 전체 흐름을 경유하는 처리 단계들과 동작을 정의후 테스트. 주로 객체지향시스템
  ㄴ 프로토타입 : 프로토타입에 먼저 테스트 진행
 - 화박
  ㄴ 제어 구조 (control structure) : 프로그램의 논리적인 복잡도를 평가후 테스트 경로들의 집합 도출
  ㄴ 루프 (loop) : 루프의 시작이나 끝에 다수의 오류가 발생한다는 경험에 기반한 테스트
  ㄴ 기본 경로 (basis path)
  ㄴ 분기 커버리지
  ㄴ 조건 커버리지
  ㄴ 데이터 흐름 
  ㄴ 돌연변이 (mutation) : 소프트웨어 코드에 일부로 오류를 추가후 테스트, 원래 소프트웨어 테스트의 결과와 비교
  ㄴ 샌드위치 : 상향식 + 하향식 동시 진행
  ㄴ 상태 커버리지
22. 통합 테스트
 - 하향식 : '깊이우선', '넓이우선', 완성되지 않은 하위 모듈의 호출을 위해 일시적 스텁을 제작해서 테스트
 - 상향식 : 최하위 레벨에서 상위 방향으로 흐름 따라 테스트, 완성되지 않은 상위 모듈이나 컴포넌트는 드라이버를 이용해서 일시적 테스트 수행
23. 알고리즘
 - 욕심쟁이 : 매번 최선을 다하게 짜면 결과론적으로 최적의 결과가 나온다는 유형, 전체 방향성과 달리 결과값이 반드시 최적의 값은 아님
 - 정복-분할 : 복잡하고 큰 문제를 원자까지 나누고 각각 세부 문제를 해결, 병합 정렬이나 거듭제곱
 - 동적 : 특정 문제가 여러단계의 반복되는 부분 문제로 구성됐을 때 단계별 문제를 해결하고 이를 기반으로 전체 문제를 구해나감
 - 백트래킹 : 전체 문제를 해결하기 위해 여러 후보의 해들 중 특정한 조건을 충족하는 해를 찾는 알고리즘, N-Queen
 - 삽입, 선택, 버블, 셀은 n, n^2, n^1.5 중 하나
 - 퀵, 힙, 병합은 nlog2n이고 퀵 worst만 n^2
24. 인터페이스
 - EAI
  ㄴ point-to-point, peer-to-peer, hub&spoke, messeging bus, hybrid
 - ESB
25. 윈도우 함수; OLAP
 - 순위 함수 : rank, dense_rank, row_number
 - 행 함수 : first_value, last_value, lag, lead
26. 트랜잭션
 - 원자성 (atomicity), 일관성 (consistency), 고립성 (isolation), 지속성 (durability)
 - 트랜잭션 상태
  ㄴ 활동, 부분완료, 완료, 실패, 철회
27. 테이블
 - 행, 레코드, 튜플, 카디나리티 (cardinality)
 - 열, 속성, 필드, 차수 (degree)
28. 시스템 카탈로그
 - db관련 메타데이터 집합체
 - syscolauth, syscolumns, systables, systabauth, sysview
29. 연산자 우선순위
 - 괄호, 단항, 이항, 조건, 대입순
30. 스케쥴링
 - 선점
   ㄴ 라운드로빈, 다단계큐, 다단계 피드백큐, SRT (short remaining time)
 - 비선점
   ㄴ FCFS (first come first service), SJF (shortest job first), HRN (highest response ratio next; SJF를 개선 및 기아문제 해결, 응답률이 높은 프로세스 선택; 계산법은
    {대기시간 + 서비스시간} / 서비스시간)
 - 데드락 -> 은행가 알고리즘 (회피)



부족한점
 - 소프트웨어 재공학
 - osi25000
 - 테스트 단위
 - 분산 db
 - 릴레이션, 카디나리티, 디그리
 - 연산자 순위
 - 서비스 지향 아키텍처 soa
 - 코코모
 - 스파이스

