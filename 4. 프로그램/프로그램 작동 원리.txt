1. 하드웨어

 설명을 위한 예시
 - mainboard : 주방
 - cpu : 요리사 뇌
 - core : 뇌의 갯수(물리적)
 - thread : 동시에 처리 가능한 연산장치의 논리적 갯수
 - processor : 생각을 처리하는 장치
 - process : 한 개의 생각
 - ram : 도마
 - gpu : 보조 예술 전문 요리사
 - repo : 냉장고
 - mouse, monitor, keyboard : 웨이터
 - program : 재료
 - rom : 주방 배치 구조
 - bus : cpu, 입출력장치, 메모리를 이어주는 팔다리
 - cache : 자주 참조하는 함수의 실제 메모리를 기억하는 장치


2. 컴파일

 정적 라이브러리 static (.lib, .a)
 - 프로그램 내에 함수 사용방법 정의

 동적 라이브러리 dynamic (.dll, .so)
 - 자주 사용하는 함수들의 집합체로 이미 컴파일링 되어 있어 시간 단축, 하지만 특정 함수만 못가져와서 단체로 가져와야 함. DLL 로딩 방식은 2가지가 있다.

 동적 라이브러리 명시적 연결
  - DLL이 메모리에 로드 되는 시점은 LoadLibrary(), 해제되는 시점은 FreeLibrary(), export 함수 사용되는 시점은 GetProcAddress()이다.
  - DLL이 필요할때마다 로드 할수 있어서 메모리 소모가 적음, DLL 로딩이 실패하더라도 대응 코드로 대처 가능
  - 함수 호출이 복잡함
 
 동적 라이브러리 암시적 연결
  - DLL이 메모리에 로드 되는 시점은 프로그램이 실행되면서 함께 로드, 해제되는 시점도 프로그램이 종료되면 해체, export 함수 사용 시점은 프로그램이 실행되는 동안 어디서나
  - 장점은 함수 호출이 간편함
  - 단점은 프로그램이 실행되는 동안 DLL이 계속 존재하기 때문에 메모리 낭비 발생, DLL 로딩 실패시 프로그램 실행이 안됨.


3. c언어 컴파일 과정

 컴파일 순서
 - 쉘 : 저장소에서 프로그램을 가져와 실행시킨다
 - 전처리기 : cpu의 전처리기로 #처리되어있는 정보 먼저 읽는다. + .i 파일 생성
 - 컴파일러 : cpu의 컴파일러로 코드를 어셈블러로 변환시킨다. + .s 파일 생성
 - 어셈블러 : cpu의 어셈블러로 어셈블러로 된 코드를 기계어로 변환시킨다. + .o 파일 생성
 - 링커 : cpu의 링커로 공유 라이브러리에 저장된 dll 위치를 모두 가져온다. + .exe 파일 생성
 - 로더 : cpu의 로더로 램에 쓴다. + 실행
 - c언어 파일을 obj파일로 변환후 library파일과 결합하면 실행파일이 된다.


4. RAM

 메모리 구성
 - 메모리는 code, data, bss, heap, shared library, stack으로 구성되어있다.
 - code는 실행할 프로그램의 코드가 저장되는 영역이며 텍스트 영역이다. 프로그램이 시작, 종료까지 메모리에 남아있다. cpu는 코드 영역에 저장된 명령을 하나씩 가져가서 처리한다.
 - data는 전역변수, 전역상수를 저장하는데 c언어에서 초기화 된 값, bss는 초기화 되지 않는 값이 저장된다.
 - heap은 유동적인 저장소를 할당하기 위한 곳으로 낮은 주소에서 높은 주소로 쓰인다.
 - shared library는 공유 라이브러리 영역으로 자주 사용하는 프로그램의 함수들을 컴파일해서 상주시키는 부분이다.
 - stack은 함수 호출과 관련되는 지역변수와 파라미터의 저장공간으로 높은 주소에서 낮은 주소로 쓰인다. 함수마다 스택프레임이라는 영역이 할당된다. LIFO방식으로 나중에 쓰인 값이 먼저 나간다. 스택 아래에는 커널의 영역이 있다.

 스택프레임
 - 함수가 선언되면 기본적으로 함수 프롤로그가 시작되고 함수가 끝나면 함수 에필로그가 쓰인다.
 - 프롤로그는 기본적으로 매개변수, ret, sfp가 있고 처음으로 매개변수를 받고 그 위에 ret는 함수가 끝나고 다시 돌아갈 주소, sfp는 이전까지 사용한 ebp의 주소가 쓰인다. 
 - sfp가 사용되는 이유는 ebp는 1개인데 스택프레임은 여러개이기 때문이다.


5. 함수 호출

 리버싱 함수 호출
 - 리버싱을 하다보면 <함수이름@plt> 의 모습을 자주 보는데 이것은 시스템에서 함수 실행하는 순서이다.
 - 윈도우에서는 IAT를 리눅스에서는 PLT, GOT를 사용한다. 
 
 IAT
 - 윈도우에서 사용하는 테이블로 window프로그램이 어떤 library에서 어떤 함수를 사용하는지를 기술한 내용을 가지고 있다.
 - IAT는 위에서 써놓은 암시적 링킹(프로그램 실행, 해제와 동시에 링킹)에 대한 로직을 제공한다.
 
 PLT, GOT
 - PLT는 외부 함수와 연결해주는 테이블로서 PLT를 통해 다른 라이브러리에 있는 함수를 호출해 사용할수 있다.
 - GOT는 PLT가 참조하는 테이블로서 함수의 실제 주소가 들어가 있다. 만약 한번도 사용안한 함수가 실행되면 GOT가 직접 메모리에서 실제 주소를 알아온다.
 - IAT와 PLT,GOT의 차이점은 IAT는 이미 실제 주소 값을 가지고 시작하는 거고 PLT,GOT는 한번도 함수 호출이 안되면 GOT가 직접 가서 함수의 주소를 알아오는 차이점이 있다.

